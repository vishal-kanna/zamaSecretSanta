import { keccak256 } from "ethers";
import { task } from "hardhat/config";
import type { TaskArguments } from "hardhat/types";

import { FhevmType } from "@fhevm/hardhat-plugin";

/**
 * Example usage:
 * ----------------
 * npx hardhat --network localhost task:address
 * npx hardhat --network localhost task:list-participants
 * npx hardhat --network localhost task:join --user <userAddress>
 * npx hardhat --network localhost task:generate-matches
 * npx hardhat --network localhost task:request-match --user <userAddress>
 * npx hardhat --network localhost task:reset
 */

task("task:address", "Print SecretSanta contract address")
    .addOptionalParam("address", "Optional contract address")
    .setAction(async (taskArgs: TaskArguments, hre) => {
        const { deployments } = hre;
        const contractDeployment = taskArgs.address
            ? { address: taskArgs.address }
            : await deployments.get("SecretSanta");
        console.log("SecretSanta address:", contractDeployment.address);
    });

task("task:list-participants", "List all participants in the pool")
    .addOptionalParam("address", "Optional contract address")
    .setAction(async (taskArgs: TaskArguments, hre) => {
        const { ethers, deployments } = hre;
        const contractDeployment = taskArgs.address
            ? { address: taskArgs.address }
            : await deployments.get("SecretSanta");

        const secretSanta = await ethers.getContractAt("SecretSanta", contractDeployment.address);
        const participants = await secretSanta.getAllParticipants();
        console.log("Participants:", participants);
    });

task("task:join", "Join the SecretSanta pool")
    .addOptionalParam("address", "Optional contract address")
    .addOptionalParam("user", "User address (default signer[0])")
    .setAction(async (taskArgs: TaskArguments, hre) => {
        const { ethers } = hre;
        const signer = taskArgs.user
            ? await ethers.getSigner(taskArgs.user)
            : (await ethers.getSigners())[0];

        const contractDeployment = taskArgs.address
            ? { address: taskArgs.address }
            : await hre.deployments.get("SecretSanta");

        const secretSanta = await ethers.getContractAt("SecretSanta", contractDeployment.address);
        const tx = await secretSanta.connect(signer).joinPool();
        await tx.wait();
        console.log(`${signer.address} joined the pool!`);
    });

task("task:generate-matches", "Generate matches (admin only)")
    .addOptionalParam("address", "Optional contract address")
    .setAction(async (taskArgs: TaskArguments, hre) => {
        const { ethers } = hre;
        const [admin] = await ethers.getSigners();
        const contractDeployment = taskArgs.address
            ? { address: taskArgs.address }
            : await hre.deployments.get("SecretSanta");

        const secretSanta = await ethers.getContractAt("SecretSanta", contractDeployment.address);
        const tx = await secretSanta.connect(admin).generateMatches();
        await tx.wait();
        console.log("Matches generated by admin!");
    });


task("task:request-match", "Request your encrypted match and decrypt it via FHE")
    .addOptionalParam("address", "Optional contract address")
    .addOptionalParam("user", "User address (default signer[0])")
    .setAction(async (taskArgs: TaskArguments, hre) => {
        const { ethers, deployments, fhevm } = hre;

        await fhevm.initializeCLIApi();

        const signer = taskArgs.user
            ? await ethers.getSigner(taskArgs.user)
            : (await ethers.getSigners())[0];

        const contractDeployment = taskArgs.address
            ? { address: taskArgs.address }
            : await hre.deployments.get("SecretSanta");

        console.log(`Using SecretSanta at: ${contractDeployment.address}`);
        const secretSanta = await ethers.getContractAt("SecretSanta", contractDeployment.address);

        // send request
        console.log(`Requesting match for ${signer.address}...`);
        const tx = await secretSanta.connect(signer).requestMyMatch();

        console.log("tx----------------", tx)
        const receipt = await tx.wait();

        // find MatchRequested event
        const eventLog = receipt?.logs.find((log: any) => {
            try {
                const parsed = secretSanta.interface.parseLog(log);
                return parsed?.name === "MatchRequested";
            } catch {
                return false;
            }
        });

        if (!eventLog) {
            console.log("No MatchRequested event found in tx logs. Exiting.");
            return;
        }
        const parsed = secretSanta.interface.parseLog(eventLog);
        const requestId = parsed.args?.requestId;
        console.log(`MatchRequested: requestId = ${requestId}`);

        // poll for processing
        console.log("Waiting for request to be processed (polling isRequestProcessed)...");
        const maxAttempts = 120;
        let attempts = 0;
        let processed = false;
        while (!processed && attempts < maxAttempts) {
            await new Promise((r) => setTimeout(r, 5000));
            try {
                processed = await secretSanta.isRequestProcessed(requestId);
            } catch {
                processed = false;
            }
            attempts++;
            process.stdout.write(processed ? `\nProcessed âœ… (attempt ${attempts})\n` : `.`);
        }

        if (!processed) {
            console.log("\nRequest not processed within timeout. Aborting.");
            return;
        }

        // Correct mapping slot computation
        const mappingSlotIndex = 1;
        const slotKey = keccak256(
            new ethers.AbiCoder().encode(
                ["address", "uint256"], // abi.encode types
                [signer.address, mappingSlotIndex]
            )
        );

        const encryptedMatchHex = await ethers.provider.getStorage(contractDeployment.address, slotKey);

        if (!encryptedMatchHex || encryptedMatchHex === ethers.ZeroHash) {
            console.log("No match ciphertext found (zero hash).");
            return;
        }

        console.log(`Ciphertext on-chain: ${encryptedMatchHex}`);

        // decrypt via CLI helper (use hre.fhevm.FhevmType if available)
        try {
            const clearMatch = await fhevm.userDecryptEuint(
                FhevmType.euint32,
                encryptedMatchHex,
                contractDeployment.address,
                signer
            );

            console.log(`Decrypted match index: ${clearMatch}`);
            console.log(`Assigned participant address: (call) getParticipant(${clearMatch})`);
            const matchedAddress = await secretSanta.getParticipant(clearMatch);
            console.log(`Assigned participant address: ${matchedAddress}`);
        } catch (err: any) {
            console.error("Decryption failed:", err?.message ?? err);
        }
    });

task("task:reset", "Reset the SecretSanta game (admin only)")
    .addOptionalParam("address", "Optional contract address")
    .setAction(async (taskArgs: TaskArguments, hre) => {
        const { ethers } = hre;
        const [admin] = await ethers.getSigners();
        const contractDeployment = taskArgs.address
            ? { address: taskArgs.address }
            : await hre.deployments.get("SecretSanta");

        const secretSanta = await ethers.getContractAt("SecretSanta", contractDeployment.address);
        const tx = await secretSanta.connect(admin).reset();
        await tx.wait();
        console.log("SecretSanta game reset by admin!");
    });
